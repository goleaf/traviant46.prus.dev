# 5.2 API Routes for AJAX

## Objective
Transition the legacy Travian AJAX endpoints under `Controller\\Ajax\\*` to Laravel-friendly API routes while keeping backwards compatibility with the existing `ajax.php?cmd=` entry point. JSON-only interactions should be served through `routes/api.php`, and highly interactive UI features should graduate to Livewire actions.

## Current State
- `main_script/include/Controller/AjaxCtrl.php` reads the `cmd` query parameter, loads a PHP class under `Controller\\Ajax\\{Cmd}` and invokes its `dispatch()` method, emitting a JSON payload directly with `json_encode`.【F:main_script/include/Controller/AjaxCtrl.php†L1-L44】
- All concrete AJAX handlers extend `Controller\\Ajax\\AjaxBase`, which injects the shared response array and exposes an `error()` helper but does not enforce request validation or HTTP status management beyond `http_response_code()`.【F:main_script/include/Controller/Ajax/AjaxBase.php†L1-L26】
- The handlers are organised in a flat namespace with functional subfolders (for example `map`, `tooltip`, `addressbook`, `paynet`), each providing a `dispatch()` method that mutates the shared response array and ends execution.

## Target Architecture
1. **Dedicated API routes** – Define Laravel API routes in `routes/api.php` that map friendly URIs (for example `/ajax/map/info`) to controller methods. Each route should return a structured JSON response (`return response()->json(...)`) instead of manually echoing output.
2. **Controller wrappers** – Create thin Laravel controllers (for example `App\Http\Controllers\Ajax\Map\InfoController`) that proxy to the existing handler classes during the migration. These controllers should translate the incoming `Request` object to the structure expected by the legacy classes and convert the result into a Laravel `JsonResponse`.
3. **Livewire integration** – For endpoints that drive interactive, stateful widgets (raid lists, map overlays, hero dialogs, etc.), replace ad-hoc AJAX calls with Livewire components so the frontend benefits from server-side state diffing and validation.
4. **Compatibility layer** – Maintain the `ajax.php?cmd=` flow during the transition by keeping `AjaxCtrl` and its dispatcher. New Laravel routes should call into the same underlying classes so both entry points behave identically until the old endpoint is retired.

## Implementation Plan
1. **Inventory endpoints**
   - Generate a registry of every `Controller\\Ajax` class and its folder (for example `Map\Info`, `Map\TileDetails`, `Tooltip\Hero`, `Addressbook\Add`). Treat nested directories as URI segments when defining API routes. Run `scripts/generate_ajax_endpoint_inventory.php` to keep `docs/modernization/ajax-endpoint-inventory.md` in sync with the codebase.
   - Document request methods (GET vs POST) and payload expectations by inspecting each controller. Prioritise high-traffic features first (map, quests, hero, marketplace). Annotate the inventory file with HTTP method and auth notes as they are confirmed so product teams can plan incremental rollouts.
2. **Bootstrap Laravel layer**
   - Ensure the Laravel skeleton (app directory, `routes/api.php`, PSR-4 autoloading) exists or is created.
   - Add an `AjaxRouteServiceProvider` to automatically register routes by scanning the registry, so future handlers require minimal boilerplate.
3. **Build controller adapters**
   - Create Laravel controllers under `App\Http\Controllers\Ajax` mirroring the legacy namespace.
   - Each adapter should:
     1. Resolve or instantiate the legacy handler (`new \Controller\Ajax\Map\Info($response)`).
     2. Pass request data (`$request->input()`, `$request->query()`) to the handler, emulating `$_POST`/`$_GET` where necessary.
     3. Capture the mutated response array and return it via `return response()->json($payload);`.
4. **Adopt Livewire where appropriate**
   - Identify endpoints with rich state or repeated polling (raid list management, hero inventory, alliance tools).
   - Replace them with Livewire components that expose public methods for the existing UI actions and emit browser events for compatibility.
   - Keep the original AJAX handler callable for clients or scripts that still rely on it, but mark it as deprecated.
5. **Testing and rollout**
   - Write feature tests hitting `routes/api.php` endpoints to ensure JSON structures match legacy responses.
   - Run browser smoke tests (or Dusk tests) for Livewire components to validate interactivity.
   - Add logging around the legacy entry point to monitor stragglers before fully removing `ajax.php`.

## Compatibility Guidelines
- Preserve the shape of the `response` array (`['error' => bool, 'errorMsg' => string|null, 'data' => []]`) while the legacy UI remains.
- Map legacy commands to intuitive route names (e.g., `cmd=mapInfo` → `POST /ajax/map/info`). Keep aliases for historical names where necessary.
- Centralise shared validation/authentication logic in middleware to avoid duplicating token checks currently scattered across handlers.
- Update JavaScript callers incrementally: first point them to the new API URLs, then refactor to Livewire once the server-side replacements exist.

## Deliverables
- Populated `routes/api.php` registering every AJAX endpoint.
- Adapter controllers and, where applicable, Livewire components replacing JavaScript-heavy flows.
- Migration checklist documenting which endpoints now live in Laravel, which still rely on the legacy dispatcher, and timelines for deprecation.
