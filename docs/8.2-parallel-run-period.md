# 8.2 Parallel Run Period

## Objective
Operate the legacy TravianT4.6 platform and the new Laravel-based platform in parallel so that live traffic can be migrated safely while minimizing disruption for existing players.

## Prerequisites
- ✅ Laravel environment deployed, smoke-tested, and connected to production-grade infrastructure (database replicas, Redis, mailers, logging, etc.).
- ✅ Session persistence shared between stacks or clear separation that ensures session stickiness for legacy users.
- ✅ Feature parity checklist signed off for all high-traffic modules (login, hero management, marketplace, combat reports, payment flow).
- ✅ Centralized observability (APM, logs, metrics, alerts) prepared to compare behaviours across both stacks.
- ✅ Incident response runbook updated with Laravel-specific escalation paths.

## Traffic Routing Strategy
1. **Login Gatekeeping**  
   - Direct new user authentications (no active legacy session cookie) to the Laravel login endpoint via the load balancer or API gateway.  
   - Existing authenticated sessions continue to resolve to the legacy PHP stack to avoid session invalidation.  
   - Record routing decisions in structured logs so that support can trace which platform handled each request.
2. **Session Affinity**  
   - Use sticky sessions or token-based routing to guarantee that a user remains on the platform they authenticated with for the duration of the session.  
   - When Laravel establishes a new session, persist identifiers in the shared cache/DB so that ancillary services (chat, payments) resolve correctly.
3. **Feature Flags**  
   - Guard Laravel-only features behind feature flags to prevent divergence during the overlap window.

## Data Consistency & Synchronization
- Mirror database writes from Laravel into the legacy schema (or vice versa) using database replication, change data capture, or queue-backed sync workers.
- Validate schema alignment daily; flag mismatched migrations immediately.
- Run automated diff scripts comparing critical aggregates (active users, troops, marketplace orders) between stacks.

## Monitoring & Observability
- **Comparative Dashboards:** build paired dashboards that plot key KPIs (login latency, request error rates, queue backlogs) for both stacks side-by-side.
- **Alerting:** configure alerts when divergence exceeds agreed thresholds (e.g., >5% difference in successful logins/hour).
- **Log Correlation:** ensure request IDs propagate through both systems to support cross-stack tracing.
- **User Feedback Loop:** instrument in-app feedback and monitor support tickets tagged with “Laravel beta”.

## Bug & Regression Handling
1. **Triage Workflow**  
   - Classify incidents by severity; critical issues trigger an immediate traffic rollback to the legacy stack.  
   - Maintain a shared incident board with SLA targets for Laravel fixes.
2. **Hotfix Path**  
   - Keep a hotfix branch ready for rapid Laravel patches; deploy through the same CI/CD pipeline but with an expedited approval gate.
3. **Knowledge Capture**  
   - After each incident, document the root cause and update automated tests to prevent regression.

## Rollback & Completion Criteria
- **Rollback Trigger:** sustained P1 incident (>15 minutes) or metrics breaching safety thresholds should automatically revert login routing to legacy.
- **Exit Criteria:** run the parallel period for at least two full game cycles (minimum 7 days) with:  
  - <1% delta in critical KPI comparisons.  
  - Zero unresolved Sev-1/Sev-2 tickets attributed to Laravel.  
  - Positive sign-off from operations, support, and product stakeholders.
- Once criteria are met, gradually migrate remaining legacy sessions by expiring old cookies and forcing re-authentication into Laravel.

## Communication Plan
- Daily stand-ups across engineering, QA, support, and community managers to review metrics.
- Publish status updates on the internal rollout portal highlighting adoption rate and open issues.
- Pre-draft player communication in case a rollback becomes necessary.

## Documentation & Next Steps
- Capture lessons learned in the migration playbook.  
- Prepare for Step 8.3: full cut-over and decommissioning of legacy components after successful completion of the parallel run.
